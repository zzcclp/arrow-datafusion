# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Test push down filter

# check LEFT/RIGHT joins with filter pushdown to both relations (when possible)

statement ok
create table t1(k int, v int);

statement ok
create table t2(k int, v int);

statement ok
insert into t1 values
  (1, 10),
  (2, 20),
  (3, 30),
  (null, 40),
  (50, null),
  (null, null);

statement ok
insert into t2 values
  (1, 11),
  (2, 21),
  (2, 22),
  (null, 41),
  (51, null),
  (null, null);

statement ok
set datafusion.explain.physical_plan_only = false;

statement ok
set datafusion.explain.logical_plan_only = true;


# left join + filter on join key -> pushed
query TT
explain select * from t1 left join t2 on t1.k = t2.k where t1.k > 1;
----
logical_plan
01)Left Join: t1.k = t2.k
02)--Filter: t1.k > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--Filter: t2.k > Int32(1)
05)----TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 left join t2 on t1.k = t2.k where t1.k > 1;
----
2 20 2 21
2 20 2 22
3 30 NULL NULL
50 NULL NULL NULL

# left join + filter on another column -> not pushed
query TT
explain select * from t1 left join t2 on t1.k = t2.k where t1.v > 1;
----
logical_plan
01)Left Join: t1.k = t2.k
02)--Filter: t1.v > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 left join t2 on t1.k = t2.k where t1.v > 1;
----
1 10 1 11
2 20 2 21
2 20 2 22
3 30 NULL NULL
NULL 40 NULL NULL

# left join + or + filter on another column -> not pushed
query TT
explain select * from t1 left join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----
logical_plan
01)Left Join: t1.k = t2.k
02)--Filter: t1.k > Int32(3) OR t1.v > Int32(20)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 left join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----
3 30 NULL NULL
50 NULL NULL NULL
NULL 40 NULL NULL


# right join + filter on join key -> pushed
query TT
explain select * from t1 right join t2 on t1.k = t2.k where t1.k > 1;
----
logical_plan
01)Inner Join: t1.k = t2.k
02)--Filter: t1.k > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--Filter: t2.k > Int32(1)
05)----TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 right join t2 on t1.k = t2.k where t1.k > 1;
----
2 20 2 21
2 20 2 22

# right join + filter on another column -> not pushed
query TT
explain select * from t1 right join t2 on t1.k = t2.k where t1.v > 1;
----
logical_plan
01)Inner Join: t1.k = t2.k
02)--Filter: t1.v > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 right join t2 on t1.k = t2.k where t1.v > 1;
----
1 10 1 11
2 20 2 21
2 20 2 22

# right join + or + filter on another column -> not pushed
query TT
explain select * from t1 right join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----
logical_plan
01)Inner Join: t1.k = t2.k
02)--Filter: t1.k > Int32(3) OR t1.v > Int32(20)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k, v]

query IIII rowsort
select * from t1 right join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----


# left anti join + filter on join key -> pushed
query TT
explain select * from t1 left anti join t2 on t1.k = t2.k where t1.k > 1;
----
logical_plan
01)LeftAnti Join: t1.k = t2.k
02)--Filter: t1.k > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--Filter: t2.k > Int32(1)
05)----TableScan: t2 projection=[k]

query II rowsort
select * from t1 left anti join t2 on t1.k = t2.k where t1.k > 1;
----
3 30
50 NULL

# left anti join + filter on another column -> not pushed
query TT
explain select * from t1 left anti join t2 on t1.k = t2.k where t1.v > 1;
----
logical_plan
01)LeftAnti Join: t1.k = t2.k
02)--Filter: t1.v > Int32(1)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k]

query II rowsort
select * from t1 left anti join t2 on t1.k = t2.k where t1.v > 1;
----
3 30
NULL 40

# left anti join + or + filter on another column -> not pushed
query TT
explain select * from t1 left anti join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----
logical_plan
01)LeftAnti Join: t1.k = t2.k
02)--Filter: t1.k > Int32(3) OR t1.v > Int32(20)
03)----TableScan: t1 projection=[k, v]
04)--TableScan: t2 projection=[k]

query II rowsort
select * from t1 left anti join t2 on t1.k = t2.k where t1.k > 3 or t1.v > 20;
----
3 30
50 NULL
NULL 40


# right anti join + filter on join key -> pushed
query TT
explain select * from t1 right anti join t2 on t1.k = t2.k where t2.k > 1;
----
logical_plan
01)RightAnti Join: t1.k = t2.k
02)--Filter: t1.k > Int32(1)
03)----TableScan: t1 projection=[k]
04)--Filter: t2.k > Int32(1)
05)----TableScan: t2 projection=[k, v]

query II rowsort
select * from t1 right anti join t2 on t1.k = t2.k where t2.k > 1;
----
51 NULL

# right anti join + filter on another column -> not pushed
query TT
explain select * from t1 right anti join t2 on t1.k = t2.k where t2.v > 1;
----
logical_plan
01)RightAnti Join: t1.k = t2.k
02)--TableScan: t1 projection=[k]
03)--Filter: t2.v > Int32(1)
04)----TableScan: t2 projection=[k, v]

query II rowsort
select * from t1 right anti join t2 on t1.k = t2.k where t2.v > 1;
----
NULL 41

# right anti join + or + filter on another column -> not pushed
query TT
explain select * from t1 right anti join t2 on t1.k = t2.k where t2.k > 3 or t2.v > 20;
----
logical_plan
01)RightAnti Join: t1.k = t2.k
02)--TableScan: t1 projection=[k]
03)--Filter: t2.k > Int32(3) OR t2.v > Int32(20)
04)----TableScan: t2 projection=[k, v]

query II rowsort
select * from t1 right anti join t2 on t1.k = t2.k where t2.k > 3 or t2.v > 20;
----
51 NULL
NULL 41


statement ok
set datafusion.explain.logical_plan_only = false;

statement ok
drop table t1;

statement ok
drop table t2;
